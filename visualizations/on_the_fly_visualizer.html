<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>On-the-Fly Balanced Merge Sort Visualizer</title>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #e74c3c;
            --light: #ecf0f1;
            --dark: #34495e;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: var(--secondary);
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: var(--light);
            border-radius: 10px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .btn-primary { background: var(--primary); color: white; }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-secondary { background: #95a5a6; color: white; }

        .visualization-area {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .visualization-area {
                grid-template-columns: 1fr;
            }
        }

        .main-viz {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ddd;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .array-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 300px;
            gap: 4px;
            padding: 20px 0;
            border-bottom: 2px solid #ddd;
        }

        .bar {
            width: 30px;
            background: var(--primary);
            border-radius: 4px 4px 0 0;
            transition: height 0.2s ease, background-color 0.2s ease;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            color: white;
            font-size: 10px;
            padding-bottom: 5px;
        }

        .bar.comparing { background: var(--danger); }
        .bar.swapping { background: var(--success); }
        .bar.sorted { background: #2ecc71; opacity: 0.8; }
        .bar.scanning { background: var(--warning); }
        
        /* Segment highlighting */
        .bar.segment-0 { background: #3498db; }
        .bar.segment-1 { background: #9b59b6; }
        .bar.segment-2 { background: #e67e22; }
        .bar.segment-3 { background: #16a085; }
        .bar.segment-4 { background: #c0392b; }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--secondary);
        }

        .panel h3 { margin-top: 0; color: var(--secondary); font-size: 1.1em; }

        .stack-viz {
            display: flex;
            flex-direction: column-reverse;
            gap: 5px;
            min-height: 150px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        .stack-item {
            background: var(--warning);
            color: white;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            font-size: 0.9em;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .log-panel {
            height: 200px;
            overflow-y: auto;
            background: #2c3e50;
            color: #ecf0f1;
            font-family: monospace;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #34495e;
            padding-bottom: 2px;
        }
        .log-entry.highlight { color: #f1c40f; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .stat-box {
            background: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .stat-val { font-size: 1.2em; font-weight: bold; color: var(--primary); }
        .stat-lbl { font-size: 0.8em; color: #7f8c8d; }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        input[type=range] { flex: 1; }

    </style>
</head>

<body>
    <div class="container">
        <h1>‚ö° On-the-Fly Balanced Merge Sort</h1>

        <div class="controls">
            <button class="btn-primary" onclick="initRandom()">üé≤ Random</button>
            <button class="btn-primary" onclick="initSorted()">üìà Sorted</button>
            <button class="btn-primary" onclick="initReverse()">üìâ Reverse</button>
            <button class="btn-primary" onclick="initNearlySorted()">‚âà Nearly</button>
            <div style="width: 20px;"></div>
            <button class="btn-success" id="btnPlay" onclick="togglePlay()">‚ñ∂ Play</button>
            <button class="btn-warning" id="btnStep" onclick="step()">‚è≠ Step</button>
            <button class="btn-danger" onclick="reset()">üîÑ Reset</button>
            
            <div class="speed-control">
                <span>Speed:</span>
                <input type="range" id="speedRange" min="1" max="100" value="50">
            </div>
        </div>

        <div class="visualization-area">
            <div class="main-viz">
                <div class="array-container" id="arrayContainer"></div>
                <div style="text-align: center; margin-top: 10px; font-weight: bold; color: var(--secondary);" id="actionDisplay">
                    Ready to start
                </div>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3>üìä Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-val" id="statComparisons">0</div>
                            <div class="stat-lbl">Comparisons</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-val" id="statSwaps">0</div>
                            <div class="stat-lbl">Swaps/Rotations</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-val" id="statSegments">0</div>
                            <div class="stat-lbl">Segments Found</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-val" id="statMerges">0</div>
                            <div class="stat-lbl">Merges Done</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>üìö Segment Stack</h3>
                    <div class="stack-viz" id="stackContainer">
                        <!-- Stack items go here -->
                    </div>
                </div>

                <div class="panel">
                    <h3>üìù Activity Log</h3>
                    <div class="log-panel" id="logPanel"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        let array = [];
        let generator = null;
        let isPlaying = false;
        let playInterval = null;
        let delay = 100;
        let stats = { comparisons: 0, swaps: 0, segments: 0, merges: 0 };
        let stack = []; // Visual representation of stack

        // --- Initialization ---
        function initRandom(size = 30) {
            array = Array.from({ length: size }, () => Math.floor(Math.random() * 100) + 1);
            reset();
        }

        function initSorted(size = 30) {
            array = Array.from({ length: size }, (_, i) => Math.floor((i / size) * 100) + 1);
            reset();
        }

        function initReverse(size = 30) {
            array = Array.from({ length: size }, (_, i) => 100 - Math.floor((i / size) * 100));
            reset();
        }

        function initNearlySorted(size = 30) {
            initSorted(size);
            // Swap 5% of elements
            for(let i=0; i<size*0.2; i++) {
                let idx1 = Math.floor(Math.random() * size);
                let idx2 = Math.floor(Math.random() * size);
                [array[idx1], array[idx2]] = [array[idx2], array[idx1]];
            }
            reset();
        }

        function reset() {
            stopPlay();
            generator = onTheFlySortGenerator(array);
            stats = { comparisons: 0, swaps: 0, segments: 0, merges: 0 };
            stack = [];
            updateUI();
            log("Algorithm reset. Ready to sort.", true);
            renderArray();
        }

        // --- Core Algorithm (Generator Version) ---
        function* onTheFlySortGenerator(arr) {
            const n = arr.length;
            const segmentsStack = []; // Actual stack for logic: [start, end]
            let i = 0;

            while (i < n) {
                // Phase 1: Detect Segment
                yield { type: 'action', msg: `Scanning for segment starting at index ${i}` };
                
                // Detect segment logic
                let start = i;
                let end = start + 1;
                
                if (start >= n) {
                    end = start;
                } else if (end < n) {
                    yield { type: 'compare', indices: [start, end] };
                    if (arr[start] > arr[end]) {
                        // Descending run
                        log(`Detected DESCENDING run starting at ${start}`);
                        while (end < n) {
                            yield { type: 'compare', indices: [end-1, end] };
                            if (arr[end-1] > arr[end]) {
                                end++;
                            } else {
                                break;
                            }
                        }
                        yield* reverseSliceGenerator(arr, start, end);
                    } else {
                        // Ascending run
                        log(`Detected ASCENDING run starting at ${start}`);
                        while (end < n) {
                            yield { type: 'compare', indices: [end-1, end] };
                            if (arr[end-1] <= arr[end]) {
                                end++;
                            } else {
                                break;
                            }
                        }
                    }
                }

                let currentStart = start;
                let currentEnd = end;
                i = end;
                
                stats.segments++;
                updateStats();

                // Phase 2: Stack Balance
                while (segmentsStack.length > 0) {
                    const top = segmentsStack[segmentsStack.length - 1];
                    const topLen = top[1] - top[0];
                    const currentLen = currentEnd - currentStart;

                    // Visualization update
                    stack = [...segmentsStack, [currentStart, currentEnd]];
                    updateStackUI();

                    log(`Checking balance: Top(${topLen}) vs Current(${currentLen})`);
                    yield { type: 'wait', msg: 'Checking stack balance...' };

                    if (currentLen < topLen) {
                        log("Balance OK. Pushing to stack.");
                        break;
                    }

                    log("Balance violation! Merging top 2 segments.");
                    segmentsStack.pop();
                    
                    // Merge animation
                    yield* symmergeGenerator(arr, top[0], currentStart, currentEnd);
                    stats.merges++;
                    updateStats();
                    
                    currentStart = top[0];
                }

                segmentsStack.push([currentStart, currentEnd]);
                stack = [...segmentsStack];
                updateStackUI();
            }

            // Phase 3: Final Merges
            while (segmentsStack.length > 1) {
                log("Final cleanup: Merging remaining segments.");
                const a = segmentsStack.pop();
                const b = segmentsStack.pop();
                
                // Visualization update
                stack = [...segmentsStack, b, a]; // Show them on stack before merge
                updateStackUI();

                yield* symmergeGenerator(arr, b[0], a[0], a[1]);
                stats.merges++;
                updateStats();
                
                segmentsStack.push([b[0], a[1]]);
                stack = [...segmentsStack];
                updateStackUI();
            }

            log("Sorting Complete! üéâ", true);
            stack = [];
            updateStackUI();
            yield { type: 'finish' };
        }

        function* reverseSliceGenerator(arr, start, end) {
            log(`Reversing range [${start}, ${end})`);
            let i = start;
            let j = end - 1;
            while (i < j) {
                yield { type: 'swap', indices: [i, j] };
                [arr[i], arr[j]] = [arr[j], arr[i]];
                stats.swaps++;
                updateStats();
                i++;
                j--;
            }
        }

        function* symmergeGenerator(arr, first, middle, last) {
            yield { type: 'action', msg: `Merging [${first}-${middle}) and [${middle}-${last})` };
            
            if (first >= middle || middle >= last) return;
            
            if (last - first === 1) return;
            
            if (last - first === 2) {
                yield { type: 'compare', indices: [first, middle] };
                if (arr[middle] < arr[first]) {
                    yield { type: 'swap', indices: [first, middle] };
                    [arr[first], arr[middle]] = [arr[middle], arr[first]];
                    stats.swaps++;
                }
                return;
            }

            const mid1 = Math.floor((first + middle) / 2);
            const value = arr[mid1];
            
            // Binary search for mid2
            let left = middle;
            let right = last;
            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                yield { type: 'compare', indices: [mid1, mid] }; // Visualizing the comparison
                if (arr[mid] < value) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            const mid2 = left;

            const newMid = mid1 + (mid2 - middle);
            
            yield* rotateRangeGenerator(arr, mid1, middle, mid2);
            
            yield* symmergeGenerator(arr, first, mid1, newMid);
            yield* symmergeGenerator(arr, newMid + 1, mid2, last);
        }

        function* rotateRangeGenerator(arr, first, middle, last) {
            if (first === middle || middle === last) return;
            log(`Rotating block [${first}, ${middle}, ${last})`);
            yield* reverseSliceGenerator(arr, first, middle);
            yield* reverseSliceGenerator(arr, middle, last);
            yield* reverseSliceGenerator(arr, first, last);
        }

        // --- UI & Control Logic ---

        function step() {
            if (!generator) return;
            
            const res = generator.next();
            
            if (res.done) {
                stopPlay();
                renderArray(null, null, true); // Render as sorted
                return;
            }

            const event = res.value;
            handleEvent(event);
        }

        function handleEvent(event) {
            if (event.type === 'compare') {
                stats.comparisons++;
                updateStats();
                renderArray(event.indices, null);
            } else if (event.type === 'swap') {
                renderArray(null, event.indices);
            } else if (event.type === 'action') {
                document.getElementById('actionDisplay').textContent = event.msg;
            } else if (event.type === 'wait') {
                document.getElementById('actionDisplay').textContent = event.msg;
            }
        }

        function togglePlay() {
            if (isPlaying) {
                stopPlay();
            } else {
                startPlay();
            }
        }

        function startPlay() {
            isPlaying = true;
            document.getElementById('btnPlay').textContent = "‚è∏ Pause";
            document.getElementById('btnStep').disabled = true;
            
            const runLoop = () => {
                if (!isPlaying) return;
                step();
                setTimeout(runLoop, delay);
            };
            runLoop();
        }

        function stopPlay() {
            isPlaying = false;
            document.getElementById('btnPlay').textContent = "‚ñ∂ Play";
            document.getElementById('btnStep').disabled = false;
        }

        // --- Rendering ---

        function renderArray(comparingIndices = null, swappingIndices = null, isFinished = false) {
            const container = document.getElementById('arrayContainer');
            container.innerHTML = '';
            
            const maxValue = Math.max(...array);

            array.forEach((val, idx) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(val / maxValue) * 100}%`;
                bar.textContent = val;

                if (isFinished) {
                    bar.classList.add('sorted');
                } else if (comparingIndices && comparingIndices.includes(idx)) {
                    bar.classList.add('comparing');
                } else if (swappingIndices && swappingIndices.includes(idx)) {
                    bar.classList.add('swapping');
                } else {
                    // Color by segment if in stack
                    let inSegment = false;
                    stack.forEach((seg, segIdx) => {
                        if (idx >= seg[0] && idx < seg[1]) {
                            bar.classList.add(`segment-${segIdx % 5}`);
                            inSegment = true;
                        }
                    });
                }

                container.appendChild(bar);
            });
        }

        function updateStackUI() {
            const container = document.getElementById('stackContainer');
            container.innerHTML = '';
            stack.forEach(seg => {
                const div = document.createElement('div');
                div.className = 'stack-item';
                div.textContent = `[${seg[0]} - ${seg[1]}) Size: ${seg[1] - seg[0]}`;
                container.appendChild(div);
            });
        }

        function updateStats() {
            document.getElementById('statComparisons').textContent = stats.comparisons;
            document.getElementById('statSwaps').textContent = stats.swaps;
            document.getElementById('statSegments').textContent = stats.segments;
            document.getElementById('statMerges').textContent = stats.merges;
        }

        function log(msg, highlight = false) {
            const panel = document.getElementById('logPanel');
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (highlight ? ' highlight' : '');
            entry.textContent = `> ${msg}`;
            panel.prepend(entry);
        }

        function updateUI() {
            updateStats();
            updateStackUI();
            document.getElementById('logPanel').innerHTML = '';
        }

        // Speed control
        document.getElementById('speedRange').addEventListener('input', (e) => {
            // Invert: 100 is fast (1ms), 1 is slow (500ms)
            delay = 500 - (e.target.value * 4.9); 
        });

        // Initial load
        initRandom();

    </script>
</body>

</html>